#include <LedControl.h>

// MAX7219: DIN=11, CLK=13, CS=10
LedControl mx(11, 13, 10, 1);

static const byte SIZE = 8;
static const unsigned long STEP_MS = 300;

byte cur[SIZE];   // fiecare element = un rând, bit x = celula (x)
byte nxt[SIZE];
byte prev[SIZE];

unsigned long tick = 0;

static inline byte getCell(const byte rows[SIZE], int x, int y) {
  return (rows[y] >> x) & 1;
}

static void fillRandom(byte rows[SIZE]) {
  for (byte y = 0; y < SIZE; y++) {
    byte r = 0;
    for (byte x = 0; x < SIZE; x++) {
      if (random(2)) r |= (1 << x);
    }
    rows[y] = r;
  }
}

static void show(const byte rows[SIZE]) {
  for (byte y = 0; y < SIZE; y++) {
    mx.setRow(0, y, rows[y]);
  }
}

static byte neighborsOf(const byte rows[SIZE], int x, int y) {
  byte n = 0;
  for (int yy = y - 1; yy <= y + 1; yy++) {
    for (int xx = x - 1; xx <= x + 1; xx++) {
      if (xx == x && yy == y) continue;
      if (xx < 0 || xx >= SIZE || yy < 0 || yy >= SIZE) continue;
      n += getCell(rows, xx, yy);
    }
  }
  return n;
}

static void nextGen(const byte in[SIZE], byte out[SIZE]) {
  for (byte y = 0; y < SIZE; y++) {
    byte row = 0;

    for (byte x = 0; x < SIZE; x++) {
      byte alive = (in[y] >> x) & 1;
      byte n = neighborsOf(in, x, y);

      bool newAlive = alive ? (n == 2 || n == 3) : (n == 3);
      if (newAlive) row |= (1 << x);
    }

    out[y] = row;
  }
}

static bool stableComparedToPrev(const byte candidate[SIZE], byte prevState[SIZE], const byte current[SIZE]) {
  // în codul tău: stabil dacă nextGrid == prevGrid, apoi prevGrid = grid
  // aici: stabil dacă nxt == prev, apoi prev = cur
  bool same = true;
  for (byte y = 0; y < SIZE; y++) {
    if (candidate[y] != prevState[y]) { same = false; break; }
  }
  for (byte y = 0; y < SIZE; y++) prevState[y] = current[y];
  return same;
}

void setup() {
  mx.shutdown(0, false);
  mx.setIntensity(0, 8);
  mx.clearDisplay(0);

  randomSeed(analogRead(A0));

  fillRandom(cur);
  for (byte i = 0; i < SIZE; i++) prev[i] = cur[i]; // echivalent cu copyGrid(grid, prevGrid)
  show(cur);
}

void loop() {
  unsigned long now = millis();
  if (now - tick < STEP_MS) return;
  tick = now;

  nextGen(cur, nxt);

  if (stableComparedToPrev(nxt, prev, cur)) {
    fillRandom(cur);          // autoreset ca în original
    for (byte i = 0; i < SIZE; i++) prev[i] = cur[i];
  } else {
    for (byte i = 0; i < SIZE; i++) cur[i] = nxt[i];
  }

  show(cur);
}
